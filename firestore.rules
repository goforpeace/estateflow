rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a signed-in-user access control model.
     * All data access, both read and write, is restricted to authenticated users.
     * This provides a good baseline level of security for a collaborative application
     * while allowing any team member to work with the data.
     *
     * Data Structure: Data is organized into top-level collections like 'projects', 'customers',
     * and 'office_expenses'. Project-specific data, such as 'flats' and 'transactions', are
     * logically nested in subcollections under their respective project documents. This hierarchical
     * structure mirrors the application's domain logic.
     *
     * Key Security Decisions:
     * - Signed-in Access: All operations are gated behind an `isSignedIn()` check. There is no
     *   public or anonymous user access to any data.
     * - Role Management: An admin role system is in place (`/roles_admin`) but is currently
     *   only used for granting roles, not for restricting general data access. This allows for
     *   easy transition to a stricter RBAC model in the future.
     * - No User Enumeration: The `/roles_admin` collection is not readable by anyone, preventing
     *   clients from discovering who the administrators are.
     * - Relational Integrity: On document creation, rules ensure that IDs stored within the
     *   document data (e.g., `projectId`) match the IDs in the document path. These IDs are
     *   enforced as immutable on update to prevent re-parenting documents.
     * - Prototyping Flexibility: While authorization is based on sign-in status, data shape validation is purposefully
     *   omitted to allow for rapid frontend development and iteration.
     */

    // --------------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has an 'admin' role.
     * The role is granted if a document with the user's UID exists in the 'roles_admin' collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Verifies that a write operation is for an existing document.
     * Crucial for protecting against unintended writes on non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * A composite check for signed-in user update and delete operations.
     * Ensures the user is signed in AND the document already exists.
     */
    function canWriteExisting() {
      return isSignedIn() && isExistingDoc();
    }

    // --------------------------------------------------------------------------
    // Collection Rules
    // --------------------------------------------------------------------------

    /**
     * @description Manages user profile information.
     * @path /users/{userId}
     * @allow (read, create, update) A user can manage their own profile.
     * @deny (list, delete) No one can list or delete user profiles directly.
     * @principle Enforces user-specific ownership for personal data.
     */
    match /users/{userId} {
      allow read, create, update: if isSignedIn() && request.auth.uid == userId;
      allow list, delete: if false;
    }

    /**
     * @description Manages real estate projects. Any signed-in user can read or write project data.
     * @path /projects/{projectId}
     * @allow (get) A signed-in user reads a project document: `get /projects/proj_123`
     * @deny (create) An anonymous user tries to create a project: `create /projects/proj_456` (auth: null)
     * @principle Enforces signed-in access for core business entities. Validates path integrity on create.
     */
    match /projects/{projectId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.id == projectId;
      allow update: if canWriteExisting() && request.resource.data.id == resource.data.id;
      allow delete: if canWriteExisting();

      /**
       * @description Manages flats within a specific project. Access is granted to any signed-in user.
       * @path /projects/{projectId}/flats/{flatId}
       * @allow (create) A signed-in user adds a new flat to a project: `create /projects/proj_123/flats/flat_A`
       * @deny (list) An anonymous user tries to list flats: `list /projects/proj_123/flats` (auth: null)
       * @principle Secures subcollection data based on authentication. Enforces relational integrity with the parent document.
       */
      match /flats/{flatId} {
        allow get: if isSignedIn();
        allow list: if isSignedIn();
        allow create: if isSignedIn() && request.resource.data.projectId == projectId;
        allow update: if canWriteExisting() && request.resource.data.projectId == resource.data.projectId;
        allow delete: if canWriteExisting();
      }

      /**
       * @description Manages cash inflow transactions for a project. Access is granted to any signed-in user.
       * @path /projects/{projectId}/inflow_transactions/{inflowTransactionId}
       * @allow (get) A signed-in user reads a specific transaction: `get /projects/proj_123/inflow_transactions/trans_abc`
       * @deny (update) An anonymous user tries to modify a transaction: `update /projects/proj_123/inflow_transactions/trans_abc` (auth: null)
       * @principle Secures subcollection data based on authentication. Enforces relational integrity with the parent document.
       */
      match /inflow_transactions/{inflowTransactionId} {
        allow get: if isSignedIn();
        allow list: if isSignedIn();
        allow create: if isSignedIn() && request.resource.data.projectId == projectId;
        allow update: if canWriteExisting() && request.resource.data.projectId == resource.data.projectId;
        allow delete: if canWriteExisting();
      }

      /**
       * @description Manages cash outflow (expense) transactions for a project. Access is granted to any signed-in user.
       * @path /projects/{projectId}/outflow_transactions/{outflowTransactionId}
       * @allow (delete) A signed-in user deletes an expense record: `delete /projects/proj_123/outflow_transactions/trans_xyz`
       * @deny (create) An anonymous user tries to create an expense: `create /projects/proj_123/outflow_transactions/trans_new` (auth: null)
       * @principle Secures subcollection data based on authentication. Enforces relational integrity with the parent document.
       */
      match /outflow_transactions/{outflowTransactionId} {
        allow get: if isSignedIn();
        allow list: if isSignedIn();
        allow create: if isSignedIn() && request.resource.data.projectId == projectId;
        allow update: if canWriteExisting() && request.resource.data.projectId == resource.data.projectId;
        allow delete: if canWriteExisting();
      }
    }

    /**
     * @description Manages customer information. Any signed-in user can access customer data.
     * @path /customers/{customerId}
     * @allow (list) A signed-in user lists all customers: `list /customers`
     * @deny (get) An anonymous user tries to read customer data: `get /customers/cust_123` (auth: null)
     * @principle Protects sensitive customer information by restricting access to authenticated users.
     */
    match /customers/{customerId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.id == customerId;
      allow update: if canWriteExisting() && request.resource.data.id == resource.data.id;
      allow delete: if canWriteExisting();
    }
    
    /**
     * @description Manages sales records. Any signed-in user can manage sales records.
     * @path /sales/{saleId}
     */
    match /sales/{saleId} {
      allow read, write: if isSignedIn();
    }

    /**
     * @description Manages expense records. Any signed-in user can manage expense records.
     * @path /expenses/{expenseId}
     */
    match /expenses/{expenseId} {
      allow read, write: if isSignedIn();
    }
    
    /**
     * @description Manages expense item records. Any signed-in user can manage expense items.
     * @path /expenseItems/{itemId}
     */
    match /expenseItems/{itemId} {
      allow read, write: if isSignedIn();
    }
    
    /**
     * @description Manages vendors. Any signed-in user can manage vendors.
     * @path /vendors/{vendorId}
     */
    match /vendors/{vendorId} {
      allow read, write: if isSignedIn();
    }
    
     /**
     * @description Manages counters. Any signed-in user can manage counters.
     * @path /counters/{counterId}
     */
    match /counters/{counterId} {
      allow read, write: if isSignedIn();
    }


    /**
     * @description Manages general office expenses. Any signed-in user can manage these records.
     * @path /office_expenses/{officeExpenseId}
     * @allow (create) A signed-in user records a new office expense: `create /office_expenses/exp_abc`
     * @deny (list) An anonymous user tries to list expenses: `list /office_expenses` (auth: null)
     * @principle Restricts financial data management to authenticated users.
     */
    match /office_expenses/{officeExpenseId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.id == officeExpenseId;
      allow update: if canWriteExisting() && request.resource.data.id == resource.data.id;
      allow delete: if canWriteExisting();

      /**
       * @description Manages the allocation of office costs to projects. Access is granted to any signed-in user.
       * @path /office_expenses/{officeExpenseId}/cost_allocations/{costAllocationId}
       * @allow (get) A signed-in user reads a cost allocation record: `get /office_expenses/exp_abc/cost_allocations/alloc_1`
       * @deny (create) An anonymous user tries to create an allocation: `create /office_expenses/exp_abc/cost_allocations/alloc_2` (auth: null)
       * @principle Secures subcollection data based on authentication. Enforces relational integrity with the parent document.
       */
      match /cost_allocations/{costAllocationId} {
        allow get: if isSignedIn();
        allow list: if isSignedIn();
        allow create: if isSignedIn() && request.resource.data.officeExpenseId == officeExpenseId;
        allow update: if canWriteExisting() && request.resource.data.officeExpenseId == resource.data.officeExpenseId;
        allow delete: if canWriteExisting();
      }
    }

    /**
     * @description Manages admin role assignments. Document existence confers the 'admin' role.
     * @path /roles_admin/{userId}
     * @allow (create) An existing admin grants admin role to another user: `create /roles_admin/user_xyz` (auth: admin)
     * @deny (create) A non-admin user tries to make themselves an admin: `create /roles_admin/user_abc` (auth: non-admin)
     * @deny (get) Any user tries to read a role document: `get /roles_admin/user_xyz` (auth: any)
     * @principle Prevents privilege escalation by ensuring only admins can manage roles. Prevents user enumeration by disallowing reads.
     */
    match /roles_admin/{userId} {
      allow get: if false;
      allow list: if false;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
  }
}
