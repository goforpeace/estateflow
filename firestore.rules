/**
 * Core Philosophy:
 * This ruleset allows any authenticated user to perform read and write operations.
 * This is a permissive setup for rapid prototyping. For production, you should
 * implement more granular, role-based access control.
 *
 * Data Structure:
 * The data is organized into several top-level collections: /users, /projects,
 * /customers, /officeExpenses and /sales. Project-specific data, such as /flats and
 * various transaction types, are nested as subcollections under /projects/{projectId}.
 *
 * Key Security Decisions:
 * - Authenticated Access: All endpoints require a user to be authenticated. There is
 *   no public or anonymous access to any data.
 * - User Data Privacy: A user can only read and update their own profile in /users.
 * - Write Integrity: On document creation, relational integrity is enforced by
 *   validating that denormalized IDs (like 'projectId' in a subcollection document)
 *   match the document's path.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ---------------- HELPER FUNCTIONS ----------------

    /**
     * Returns true if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document being written to already exists.
     * CRITICAL for all update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Returns true if user is authenticated.
     */
    function canAccessBusinessData() {
      return isSignedIn();
    }
    
    // --- Data Integrity Validation Helpers (Prototyping Mode) ---

    /**
     * On create, validates that the document's internal `id` field matches the `userId` in the path.
     */
    function hasValidUserIdOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * On update, ensures the internal `id` field is immutable.
     */
    function isUserIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * On create, validates that the subcollection document's `projectId` field matches the `projectId` in the path.
     */
    function hasValidProjectIdOnCreate(projectId) {
      return request.resource.data.projectId == projectId;
    }

    /**
     * On update, ensures the subcollection document's `projectId` field is immutable.
     */
    function isProjectIdImmutable() {
      return request.resource.data.projectId == resource.data.projectId;
    }

    // ---------------- COLLECTION RULES ----------------

    /**
     * @description Manages user profiles. A user can manage their own profile.
     * @path /users/{userId}
     * @allow (get) An authenticated user `user_abc` reading their own profile at `/users/user_abc`.
     * @deny (list) Any user trying to list all documents in the `/users` collection.
     * @deny (update) User `user_abc` trying to update the profile of `user_xyz`.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasValidUserIdOnCreate(userId);
      allow update: if isOwner(userId) && isExistingDoc() && isUserIdImmutable();
      allow delete: if false;
    }

    /**
     * @description Manages projects. Access is granted to any authenticated user.
     * @path /projects/{projectId}
     * @allow (get) Any signed-in user reading a project document.
     * @allow (create) Any signed-in user creating a new project.
     * @principle Enforces authenticated access for all business data.
     */
    match /projects/{projectId} {
      allow read, write: if canAccessBusinessData();

      /**
       * @description Manages flats within a project. Access is granted to any authenticated user.
       * @path /projects/{projectId}/flats/{flatId}
       * @allow (list) Any signed-in user listing all flats for a project.
       * @allow (create) Any signed-in user creating a new flat document ensuring the `projectId` field matches the path.
       * @principle Enforces authenticated access and validates relational integrity.
       */
      match /flats/{flatId} {
        allow read: if canAccessBusinessData();
        allow create: if canAccessBusinessData() && hasValidProjectIdOnCreate(projectId);
        allow update: if canAccessBusinessData() && isExistingDoc() && isProjectIdImmutable();
        allow delete: if canAccessBusinessData() && isExistingDoc();
      }

      /**
       * @description Manages inflow transactions for a project. Access is granted to any authenticated user.
       * @path /projects/{projectId}/inflowTransactions/{inflowTransactionId}
       * @allow (list) Any signed-in user listing all inflow transactions for a project.
       * @principle Enforces authenticated access and validates relational integrity.
       */
      match /inflowTransactions/{inflowTransactionId} {
        allow read: if canAccessBusinessData();
        allow create: if canAccessBusinessData() && hasValidProjectIdOnCreate(projectId);
        allow update: if canAccessBusinessData() && isExistingDoc() && isProjectIdImmutable();
        allow delete: if canAccessBusinessData() && isExistingDoc();
      }

      /**
       * @description Manages outflow transactions for a project. Access is granted to any authenticated user.
       * @path /projects/{projectId}/outflowTransactions/{outflowTransactionId}
       * @principle Enforces authenticated access and validates relational integrity.
       */
      match /outflowTransactions/{outflowTransactionId} {
        allow read: if canAccessBusinessData();
        allow create: if canAccessBusinessData() && hasValidProjectIdOnCreate(projectId);
        allow update: if canAccessBusinessData() && isExistingDoc() && isProjectIdImmutable();
        allow delete: if canAccessBusinessData() && isExistingDoc();
      }

      /**
       * @description Manages office cost allocations for a project. Access is granted to any authenticated user.
       * @path /projects/{projectId}/officeCostAllocations/{officeCostAllocationId}
       * @principle Enforces authenticated access and validates relational integrity.
       */
      match /officeCostAllocations/{officeCostAllocationId} {
        allow read: if canAccessBusinessData();
        allow create: if canAccessBusinessData() && hasValidProjectIdOnCreate(projectId);
        allow update: if canAccessBusinessData() && isExistingDoc() && isProjectIdImmutable();
        allow delete: if canAccessBusinessData() && isExistingDoc();
      }
    }
    
    /**
     * @description Enables collection group queries on inflow transactions.
     * @path /{path=**}/inflowTransactions/{inflowTransactionId}
     * @principle Required for cross-project queries like fetching all payments for a single customer.
     */
    match /{path=**}/inflowTransactions/{inflowTransactionId} {
        allow read: if canAccessBusinessData();
    }

    /**
     * @description Manages customer data. Access is granted to any authenticated user.
     * @path /customers/{customerId}
     * @principle Enforces authenticated access for all business data.
     */
    match /customers/{customerId} {
      allow read, write: if canAccessBusinessData();
    }
    
    /**
     * @description Manages sales data. Access is granted to any authenticated user.
     * @path /sales/{saleId}
     * @principle Enforces authenticated access for all business data.
     */
    match /sales/{saleId} {
      allow read, write: if canAccessBusinessData();
    }

    /**
     * @description Manages general office expenses. Access is granted to any authenticated user.
     * @path /officeExpenses/{officeExpenseId}
     * @principle Enforces authenticated access for all business data.
     */
    match /officeExpenses/{officeExpenseId} {
      allow read, write: if canAccessBusinessData();
    }
  }
}
