rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a strict, role-based access control (RBAC) model.
     * All data access, both read and write, is restricted to authenticated users who have been
     * explicitly granted an 'admin' role. This provides a high level of security suitable for an
     * internal business management application.
     *
     * Data Structure: Data is organized into top-level collections like 'projects', 'customers',
     * and 'office_expenses'. Project-specific data, such as 'flats' and 'transactions', are
     * logically nested in subcollections under their respective project documents. This hierarchical
     * structure mirrors the application's domain logic.
     *
     * Key Security Decisions:
     * - Admin-Only Access: All operations are gated behind an `isAdmin()` check. There is no
     *   public or general user access to any data.
     * - Role Management: The 'admin' role is conferred by the existence of a document in the
     *   `/roles_admin/{userId}` collection. Only existing admins can add or remove other admins.
     * - No User Enumeration: The `/roles_admin` collection is not readable by anyone, preventing
     *   clients from discovering who the administrators are.
     * - Relational Integrity: On document creation, rules ensure that IDs stored within the
     *   document data (e.g., `projectId`) match the IDs in the document path. These IDs are
     *   enforced as immutable on update to prevent re-parenting documents.
     * - Prototyping Flexibility: While authorization is strict, data shape validation is purposefully
     *   omitted to allow for rapid frontend development and iteration.
     */

    // --------------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has an 'admin' role.
     * The role is granted if a document with the user's UID exists in the 'roles_admin' collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Verifies that a write operation is for an existing document.
     * Crucial for protecting against unintended writes on non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * A composite check for admin-level update and delete operations.
     * Ensures the user is an admin AND the document already exists.
     */
    function canAdminWriteExisting() {
      return isAdmin() && isExistingDoc();
    }

    // --------------------------------------------------------------------------
    // Collection Rules
    // --------------------------------------------------------------------------

    /**
     * @description Manages user profile information.
     * @path /users/{userId}
     * @allow (read, create, update) A user can manage their own profile.
     * @deny (list, delete) No one can list or delete user profiles directly.
     * @principle Enforces user-specific ownership for personal data.
     */
    match /users/{userId} {
      allow read, create, update: if isSignedIn() && request.auth.uid == userId;
      allow list, delete: if false;
    }

    /**
     * @description Manages real estate projects. Only admins can read or write project data.
     * @path /projects/{projectId}
     * @allow (get) An admin reads a project document: `get /projects/proj_123` (auth: admin)
     * @deny (create) A non-admin user tries to create a project: `create /projects/proj_456` (auth: non-admin)
     * @principle Enforces strict admin-only access for core business entities. Validates path integrity on create.
     */
    match /projects/{projectId} {
      allow get: if isAdmin();
      allow list: if isSignedIn();
      allow create: if isAdmin() && request.resource.data.id == projectId;
      allow update: if canAdminWriteExisting() && request.resource.data.id == resource.data.id;
      allow delete: if canAdminWriteExisting();

      /**
       * @description Manages flats within a specific project. Access is inherited from the parent project (admin-only).
       * @path /projects/{projectId}/flats/{flatId}
       * @allow (create) An admin adds a new flat to a project: `create /projects/proj_123/flats/flat_A` (auth: admin)
       * @deny (list) A signed-in, non-admin user tries to list flats: `list /projects/proj_123/flats` (auth: non-admin)
       * @principle Secures subcollection data based on a global role. Enforces relational integrity with the parent document.
       */
      match /flats/{flatId} {
        allow get: if isAdmin();
        allow list: if isAdmin();
        allow create: if isAdmin() && request.resource.data.projectId == projectId;
        allow update: if canAdminWriteExisting() && request.resource.data.projectId == resource.data.projectId;
        allow delete: if canAdminWriteExisting();
      }

      /**
       * @description Manages cash inflow transactions for a project. Access is inherited (admin-only).
       * @path /projects/{projectId}/inflow_transactions/{inflowTransactionId}
       * @allow (get) An admin reads a specific transaction: `get /projects/proj_123/inflow_transactions/trans_abc` (auth: admin)
       * @deny (update) A non-admin tries to modify a transaction: `update /projects/proj_123/inflow_transactions/trans_abc` (auth: non-admin)
       * @principle Secures subcollection data based on a global role. Enforces relational integrity with the parent document.
       */
      match /inflow_transactions/{inflowTransactionId} {
        allow get: if isAdmin();
        allow list: if isAdmin();
        allow create: if isAdmin() && request.resource.data.projectId == projectId;
        allow update: if canAdminWriteExisting() && request.resource.data.projectId == resource.data.projectId;
        allow delete: if canAdminWriteExisting();
      }

      /**
       * @description Manages cash outflow (expense) transactions for a project. Access is inherited (admin-only).
       * @path /projects/{projectId}/outflow_transactions/{outflowTransactionId}
       * @allow (delete) An admin deletes an expense record: `delete /projects/proj_123/outflow_transactions/trans_xyz` (auth: admin)
       * @deny (create) An anonymous user tries to create an expense: `create /projects/proj_123/outflow_transactions/trans_new` (auth: null)
       * @principle Secures subcollection data based on a global role. Enforces relational integrity with the parent document.
       */
      match /outflow_transactions/{outflowTransactionId} {
        allow get: if isAdmin();
        allow list: if isAdmin();
        allow create: if isAdmin() && request.resource.data.projectId == projectId;
        allow update: if canAdminWriteExisting() && request.resource.data.projectId == resource.data.projectId;
        allow delete: if canAdminWriteExisting();
      }
    }

    /**
     * @description Manages customer information. Only admins can access customer data.
     * @path /customers/{customerId}
     * @allow (list) An admin lists all customers: `list /customers` (auth: admin)
     * @deny (get) A regular user tries to read customer data: `get /customers/cust_123` (auth: non-admin)
     * @principle Protects sensitive customer information by restricting access to authorized administrators.
     */
    match /customers/{customerId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin() && request.resource.data.id == customerId;
      allow update: if canAdminWriteExisting() && request.resource.data.id == resource.data.id;
      allow delete: if canAdminWriteExisting();
    }

    /**
     * @description Manages general office expenses. Only admins can manage these records.
     * @path /office_expenses/{officeExpenseId}
     * @allow (create) An admin records a new office expense: `create /office_expenses/exp_abc` (auth: admin)
     * @deny (list) An anonymous user tries to list expenses: `list /office_expenses` (auth: null)
     * @principle Restricts financial data management to trusted admin users.
     */
    match /office_expenses/{officeExpenseId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin() && request.resource.data.id == officeExpenseId;
      allow update: if canAdminWriteExisting() && request.resource.data.id == resource.data.id;
      allow delete: if canAdminWriteExisting();

      /**
       * @description Manages the allocation of office costs to projects. Access is inherited (admin-only).
       * @path /office_expenses/{officeExpenseId}/cost_allocations/{costAllocationId}
       * @allow (get) An admin reads a cost allocation record: `get /office_expenses/exp_abc/cost_allocations/alloc_1` (auth: admin)
       * @deny (create) A non-admin tries to create an allocation: `create /office_expenses/exp_abc/cost_allocations/alloc_2` (auth: non-admin)
       * @principle Secures subcollection data based on a global role. Enforces relational integrity with the parent document.
       */
      match /cost_allocations/{costAllocationId} {
        allow get: if isAdmin();
        allow list: if isAdmin();
        allow create: if isAdmin() && request.resource.data.officeExpenseId == officeExpenseId;
        allow update: if canAdminWriteExisting() && request.resource.data.officeExpenseId == resource.data.officeExpenseId;
        allow delete: if canAdminWriteExisting();
      }
    }

    /**
     * @description Manages admin role assignments. Document existence confers the 'admin' role.
     * @path /roles_admin/{userId}
     * @allow (create) An existing admin grants admin role to another user: `create /roles_admin/user_xyz` (auth: admin)
     * @deny (create) A non-admin user tries to make themselves an admin: `create /roles_admin/user_abc` (auth: non-admin)
     * @deny (get) Any user tries to read a role document: `get /roles_admin/user_xyz` (auth: any)
     * @principle Prevents privilege escalation by ensuring only admins can manage roles. Prevents user enumeration by disallowing reads.
     */
    match /roles_admin/{userId} {
      allow get: if false;
      allow list: if false;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
  }
}