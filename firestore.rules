/**
 * Core Philosophy:
 * This ruleset implements a Role-Based Access Control (RBAC) model for a real estate
 * management application. Access to business-critical data (projects, customers,
 * transactions) is governed by a user's assigned role, which is stored on their
 * user profile document. A user's own profile is protected by an ownership model.
 *
 * Data Structure:
 * The data is organized into several top-level collections: /users, /projects,
 * /customers, and /officeExpenses. Project-specific data, such as /flats and
 * various transaction types, are nested as subcollections under /projects/{projectId}
 * to enable clear, hierarchical security and queries.
 *
 * Key Security Decisions:
 * - Role-Based Access: User roles ('Admin', 'Accountant', 'Viewer') defined in
 *   /users/{userId} documents determine read/write permissions for all business
 *   data. Admins and Accountants have write access, while Viewers have read-only access.
 * - User Data Privacy: A user can only read and update their own profile in /users.
 *   An exception is made for 'Admin' users, who can read any user's profile for
 *   administrative purposes. User listing is disabled to prevent data scraping.
 * - Authenticated Access: All endpoints require a user to be authenticated. There is
 *   no public or anonymous access to any data.
 * - Write Integrity: All write operations on business data are restricted to
 *   authorized roles. On document creation, relational integrity is enforced by
 *   validating that denormalized IDs (like 'projectId' in a subcollection document)
 *   match the document's path.
 *
 * Denormalization for Authorization:
 * Authorization relies on the 'role' field denormalized onto each user's document
 * in the `/users` collection. Rules for business collections perform a `get()` request
 * to `/users/{request.auth.uid}` to check this role. This is an efficient and
 * secure pattern for implementing RBAC in Firestore.
 *
 * Structural Segregation:
 * User data is strictly segregated in the `/users` collection, which has different
 * security rules (owner-based) than the business data collections (role-based).
 * This separation ensures user privacy cannot be accidentally compromised by rules
 * meant for business data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ---------------- HELPER FUNCTIONS ----------------

    /**
     * Returns true if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document being written to already exists.
     * CRITICAL for all update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Retrieves the authenticated user's profile document.
     * Caches the result for the duration of the request evaluation.
     */
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    /**
     * Returns true if the authenticated user has one of the specified roles.
     * This function reads the user's role from their user profile document.
     */
    function hasOneOfRoles(roles) {
      return isSignedIn() && getUserData().data.role in roles;
    }

    /**
     * Returns true if user has a role that permits reading business data.
     */
    function canReadBusinessData() {
      return hasOneOfRoles(['Admin', 'Accountant', 'Viewer']);
    }

    /**
     * Returns true if user has a role that permits writing business data.
     */
    function canWriteBusinessData() {
      return hasOneOfRoles(['Admin', 'Accountant']);
    }
    
    /**
     * Returns true if the user is an Admin. Used for special permissions.
     */
    function isAdmin() {
       return hasOneOfRoles(['Admin']);
    }

    // --- Data Integrity Validation Helpers (Prototyping Mode) ---

    /**
     * On create, validates that the document's internal `id` field matches the `userId` in the path.
     */
    function hasValidUserIdOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * On update, ensures the internal `id` field is immutable.
     */
    function isUserIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * On create, validates that the subcollection document's `projectId` field matches the `projectId` in the path.
     */
    function hasValidProjectIdOnCreate(projectId) {
      return request.resource.data.projectId == projectId;
    }

    /**
     * On update, ensures the subcollection document's `projectId` field is immutable.
     */
    function isProjectIdImmutable() {
      return request.resource.data.projectId == resource.data.projectId;
    }

    // ---------------- COLLECTION RULES ----------------

    /**
     * @description Manages user profiles. A user can manage their own profile. Admins can view any profile.
     * @path /users/{userId}
     * @allow (get) An authenticated user `user_abc` reading their own profile at `/users/user_abc`.
     * @allow (get) An 'Admin' user reading any profile at `/users/user_xyz`.
     * @deny (list) Any user trying to list all documents in the `/users` collection.
     * @deny (update) User `user_abc` trying to update the profile of `user_xyz`.
     * @principle Restricts access to a user's own data tree and grants admin read override.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if false;
      allow create: if isOwner(userId) && hasValidUserIdOnCreate(userId);
      allow update: if isOwner(userId) && isExistingDoc() && isUserIdImmutable();
      allow delete: if false;
    }

    /**
     * @description Manages projects. Read access is for all authorized roles. Write access is restricted to Admins and Accountants.
     * @path /projects/{projectId}
     * @allow (get) A 'Viewer' role user reading a project document.
     * @allow (create) An 'Admin' or 'Accountant' role user creating a new project.
     * @deny (create) A 'Viewer' role user trying to create a new project.
     * @deny (update) Any user trying to modify a project without being an 'Admin' or 'Accountant'.
     * @principle Enforces Role-Based Access Control for business data.
     */
    match /projects/{projectId} {
      allow get, list: if canReadBusinessData();
      allow create: if canWriteBusinessData();
      allow update, delete: if canWriteBusinessData() && isExistingDoc();

      /**
       * @description Manages flats within a project. Inherits RBAC from parent project rules.
       * @path /projects/{projectId}/flats/{flatId}
       * @allow (list) An 'Accountant' role user listing all flats for a project.
       * @allow (create) An 'Admin' role user creating a new flat document ensuring the `projectId` field matches the path.
       * @deny (create) A 'Viewer' role user trying to create a flat.
       * @deny (update) An 'Accountant' attempting to change the `projectId` on an existing flat document.
       * @principle Enforces RBAC and validates relational integrity between parent and child documents.
       */
      match /flats/{flatId} {
        allow get, list: if canReadBusinessData();
        allow create: if canWriteBusinessData() && hasValidProjectIdOnCreate(projectId);
        allow update: if canWriteBusinessData() && isExistingDoc() && isProjectIdImmutable();
        allow delete: if canWriteBusinessData() && isExistingDoc();
      }

      /**
       * @description Manages inflow transactions for a project. Inherits RBAC from parent project rules.
       * @path /projects/{projectId}/inflowTransactions/{inflowTransactionId}
       * @allow (list) An 'Accountant' role user listing all inflow transactions for a project.
       * @allow (create) An 'Admin' role user creating a new transaction ensuring the `projectId` field matches the path.
       * @deny (delete) A 'Viewer' role user trying to delete a transaction.
       * @principle Enforces RBAC and validates relational integrity between parent and child documents.
       */
      match /inflowTransactions/{inflowTransactionId} {
        allow get, list: if canReadBusinessData();
        allow create: if canWriteBusinessData() && hasValidProjectIdOnCreate(projectId);
        allow update: if canWriteBusinessData() && isExistingDoc() && isProjectIdImmutable();
        allow delete: if canWriteBusinessData() && isExistingDoc();
      }

      /**
       * @description Manages outflow transactions for a project. Inherits RBAC from parent project rules.
       * @path /projects/{projectId}/outflowTransactions/{outflowTransactionId}
       * @allow (get) A 'Viewer' role user reading a specific outflow transaction.
       * @allow (create) An 'Accountant' role user creating a new outflow transaction.
       * @deny (update) A 'Viewer' role user trying to update an outflow transaction.
       * @principle Enforces RBAC and validates relational integrity between parent and child documents.
       */
      match /outflowTransactions/{outflowTransactionId} {
        allow get, list: if canReadBusinessData();
        allow create: if canWriteBusinessData() && hasValidProjectIdOnCreate(projectId);
        allow update: if canWriteBusinessData() && isExistingDoc() && isProjectIdImmutable();
        allow delete: if canWriteBusinessData() && isExistingDoc();
      }

      /**
       * @description Manages office cost allocations for a project. Inherits RBAC from parent project rules.
       * @path /projects/{projectId}/officeCostAllocations/{officeCostAllocationId}
       * @allow (create) An 'Admin' creating a new cost allocation, ensuring the `projectId` field is correct.
       * @allow (list) Any user with a valid business role listing cost allocations.
       * @deny (create) A 'Viewer' trying to create a new cost allocation.
       * @principle Enforces RBAC and validates relational integrity between parent and child documents.
       */
      match /officeCostAllocations/{officeCostAllocationId} {
        allow get, list: if canReadBusinessData();
        allow create: if canWriteBusinessData() && hasValidProjectIdOnCreate(projectId);
        allow update: if canWriteBusinessData() && isExistingDoc() && isProjectIdImmutable();
        allow delete: if canWriteBusinessData() && isExistingDoc();
      }
    }

    /**
     * @description Manages customer data. Read access is for all roles, write access is for Admins and Accountants.
     * @path /customers/{customerId}
     * @allow (list) A 'Viewer' role user listing all customers.
     * @allow (create) An 'Accountant' role user adding a new customer.
     * @deny (update) A 'Viewer' role user attempting to update a customer's phone number.
     * @principle Enforces Role-Based Access Control for business data.
     */
    match /customers/{customerId} {
      allow get, list: if canReadBusinessData();
      allow create: if canWriteBusinessData();
      allow update, delete: if canWriteBusinessData() && isExistingDoc();
    }

    /**
     * @description Manages general office expenses. Read access is for all roles, write is for Admins and Accountants.
     * @path /officeExpenses/{officeExpenseId}
     * @allow (get) An 'Accountant' role user fetching a single office expense document.
     * @allow (create) An 'Admin' role user creating a new office expense.
     * @deny (delete) A 'Viewer' role user trying to delete an expense.
     * @principle Enforces Role-Based Access Control for business data.
     */
    match /officeExpenses/{officeExpenseId} {
      allow get, list: if canReadBusinessData();
      allow create: if canWriteBusinessData();
      allow update, delete: if canWriteBusinessData() && isExistingDoc();
    }
  }
}